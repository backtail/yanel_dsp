#ifndef _YANEL_DSP_H_
#define _YANEL_DSP_H_

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>


typedef enum ButterworthType {
    ButterworthType_Lowpass = 0,
    ButterworthType_Highpass = 1,
    ButterworthType_Allpass = 2,
    ButterworthType_Notch = 3,
    ButterworthType_Bell = 4,
    ButterworthType_LowShelf = 5,
} ButterworthType;

typedef enum KickState {
    KickState_Idle,
    KickState_Triggered,
    KickState_Retriggered,
} KickState;

typedef enum Waveform {
    Waveform_Sine = 0,
    Waveform_Rectangle = 1,
    Waveform_Sawtooth = 2,
    Waveform_Triangle = 3,
} Waveform;

typedef struct MultiStageEnvelope_3 {
    /*
     stage time in samples
     */
    float stage_time[3];
    /*
     always between -10.0 and 10.0
     */
    float stage_slope[3];
    /*
     always between 0.0 and 1.0
     */
    float stage_level[3];
    /*
     always between 0.0 and 1.0
     */
    float stage_begin_level;
    float t;
    float envelope_value;
    int8_t current_stage;
    uint8_t retrigger_stage;
} MultiStageEnvelope_3;

/*
 Feed Forward Compressor with adjustable time slope parameters
 */
typedef struct FFCompressor {
    /*
     between 0.0 and 1.0
     */
    float threshold;
    /*
     between 1.0 and +inf
     */
    float ratio;
    /*
     between 1.0 and upper bound
     */
    float makeup_gain;
    struct MultiStageEnvelope_3 env;
    /*
     internal
     */
    bool env_triggered;
} FFCompressor;

typedef struct Compressor {
    struct FFCompressor comp;
    float sr;
} Compressor;

/*
 Raw mutable pointer that implements the `Send` trait since it's only acting on stack memory
 */
typedef float *Mutable;

/*
 Struct
 */
typedef struct MemorySlice_Mutable {
    Mutable ptr;
    size_t length;
} MemorySlice_Mutable;

typedef struct DelayLine {
    struct MemorySlice_Mutable buffer;
    size_t index;
} DelayLine;

typedef struct Comb {
    struct DelayLine delay_line;
    float feedback;
    float filter_state;
    float dampening;
    float dampening_inverse;
} Comb;

typedef struct AllPass {
    struct DelayLine delay_line;
} AllPass;

typedef struct FreeverbParams {
    float width;
    float dampening;
    float room_size;
    bool frozen;
    float mix;
} FreeverbParams;

typedef struct Freeverb {
    struct Comb combs_l[8];
    struct Comb combs_r[8];
    struct AllPass allpasses_l[4];
    struct AllPass allpasses_r[4];
    struct FreeverbParams params;
    float wet_gain_l;
    float wet_gain_r;
    float input_gain;
    float dry;
    float wet;
} Freeverb;

typedef struct BiquadCoeffs_Butterworth {
    float b0;
    float b1;
    float b2;
    float a1;
    float a2;
} BiquadCoeffs_Butterworth;

/*
 Little suite of filters in a `Biquad` topology.
 */
typedef struct Biquad_Butterworth {
    float z1;
    float z2;
    struct BiquadCoeffs_Butterworth coeffs;
} Biquad_Butterworth;

typedef struct MultiFilter {
    struct Biquad_Butterworth biquad;
    enum ButterworthType filter;
    float sr;
    float fc;
    float q;
    float gain;
} MultiFilter;

typedef struct SimpleDelay {
    struct DelayLine delay_line;
    float delay_samples;
    float feedback;
    float dry_gain;
    float wet_gain;
    bool delay_time_changed;
    float last_delay_samples;
    size_t crossfade_counter;
    size_t crossfade_samples;
} SimpleDelay;

typedef struct SoftPhaseAccumulator {
    uint32_t counter;
    float freq;
    uint32_t shift;
    float min_step;
} SoftPhaseAccumulator;

typedef struct FunctionalOscillator_SoftPhaseAccumulator {
    struct SoftPhaseAccumulator acc;
    enum Waveform wave;
} FunctionalOscillator_SoftPhaseAccumulator;

typedef struct SynthKick {
    struct MultiStageEnvelope_3 pitch_env;
    struct MultiStageEnvelope_3 volume_env;
    struct FunctionalOscillator_SoftPhaseAccumulator osc;
    float sr;
    float current_sample;
    enum KickState state;
    float global_pitch;
    float global_pitch_range;
    float retrigger_slope;
    float retrigger_fade_out_amp;
    float overdrive;
    float od_param;
} SynthKick;

/*
 Initializes `Compressor` struct
 */
struct Compressor compressor_init(float sr);

void compressor_set_attack(struct Compressor *ptr, float val);

void compressor_set_attack_slope(struct Compressor *ptr, float val);

void compressor_set_ratio(struct Compressor *ptr, float val);

void compressor_set_release(struct Compressor *ptr, float val);

void compressor_set_release_slope(struct Compressor *ptr, float val);

void compressor_set_threshold(struct Compressor *ptr, float val);

/*
 Returns next sample
 */
float compressor_tick(struct Compressor *ptr, float sample);

float f32_millis_to_samples(float val, float sr);

float f32_samples_to_millis(float val, float sr);

float f32_samples_to_seconds(float val, float sr);

float f32_seconds_to_samples(float val, float sr);

/*
 Initializes `Freeverb` struct. `buffer` needs to be `length >= 25450` for `sr = 48000`. Otherwise will panic!
 */
struct Freeverb freeverb_init(float sr,
                              float *buffer,
                              size_t length);

/*
 Sample rate depending calculations should be performed earlier!
 */
void freeverb_set_all_params(struct Freeverb *ptr, struct FreeverbParams *params);

/*
 Returns next stereo samples. Raw pointer `stereo_samples` assumes to have exactly two elements!
 */
void freeverb_tick(struct Freeverb *ptr, float *stereo_samples);

/*
 Initializes `MultiFilter` struct.
 */
struct MultiFilter multifilter_init(float sr);

/*
 Sample rate depending calculations should be performed earlier!
 */
void multifilter_set_all_params(struct MultiFilter *ptr,
                                enum ButterworthType filter,
                                float freq,
                                float q,
                                float gain);

/*
 Returns next stereo samples. Raw pointer `stereo_samples` assumes to have exactly two elements!
 */
float multifilter_tick(struct MultiFilter *ptr, float sample);

/*
 Initializes `SimpleDelay` struct
 */
struct SimpleDelay simple_delay_init(void);

/*
 Initializes `SimpleDelay` delay buffer
 */
void simple_delay_set_buffer(struct SimpleDelay *ptr, float *buffer, size_t length);

/*
 Feedback can reach max. 100%
 */
void simple_delay_set_feedback(struct SimpleDelay *ptr, float feedback);

/*
 Sample rate depending calculations should be performed earlier!
 */
void simple_delay_set_length(struct SimpleDelay *ptr, float len_in_samples);

/*
 Dry/Wet mixing
 */
void simple_delay_set_mix(struct SimpleDelay *ptr, float mix);

/*
 Returns next sample
 */
float simple_delay_tick(struct SimpleDelay *ptr, float sample);

/*
 Initializes `SynthKick` struct
 */
struct SynthKick synth_kick_init(float sr);

/*
 Only accepts values between 0.0 and 1.0, otherwise clamps
 */
void synth_kick_set_attack(struct SynthKick *ptr, float val);

/*
 Only accepts values between 0.0 and 1.0, otherwise clamps
 */
void synth_kick_set_decay(struct SynthKick *ptr, float val);

/*
 Only accepts values between 0.0 and 1.0, otherwise clamps
 */
void synth_kick_set_decay_pitch(struct SynthKick *ptr, float val);

/*
 Only accepts values between -1.0 and 1.0, otherwise clamps
 */
void synth_kick_set_env_slope(struct SynthKick *ptr, float val);

/*
 Only accepts values between 0.0 and 1.0, otherwise clamps
 */
void synth_kick_set_pitch(struct SynthKick *ptr, float val);

/*
 Returns next sample
 */
float synth_kick_tick(struct SynthKick *ptr);

/*
 Triggers the kick
 */
void synth_kick_trigger(struct SynthKick *ptr);

#endif  /* _YANEL_DSP_H_ */
